type AggregateDiagnosis {
  count: Int!
}

type AggregateEncounter {
  count: Int!
}

type AggregateReference {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Diagnosis {
  id: ID!
  use: String!
  condition: Reference
}

type DiagnosisConnection {
  pageInfo: PageInfo!
  edges: [DiagnosisEdge]!
  aggregate: AggregateDiagnosis!
}

input DiagnosisCreateInput {
  id: ID
  use: String!
  condition: ReferenceCreateOneInput
}

input DiagnosisCreateManyInput {
  create: [DiagnosisCreateInput!]
  connect: [DiagnosisWhereUniqueInput!]
}

type DiagnosisEdge {
  node: Diagnosis!
  cursor: String!
}

enum DiagnosisOrderByInput {
  id_ASC
  id_DESC
  use_ASC
  use_DESC
}

type DiagnosisPreviousValues {
  id: ID!
  use: String!
}

input DiagnosisScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  use: String
  use_not: String
  use_in: [String!]
  use_not_in: [String!]
  use_lt: String
  use_lte: String
  use_gt: String
  use_gte: String
  use_contains: String
  use_not_contains: String
  use_starts_with: String
  use_not_starts_with: String
  use_ends_with: String
  use_not_ends_with: String
  AND: [DiagnosisScalarWhereInput!]
  OR: [DiagnosisScalarWhereInput!]
  NOT: [DiagnosisScalarWhereInput!]
}

type DiagnosisSubscriptionPayload {
  mutation: MutationType!
  node: Diagnosis
  updatedFields: [String!]
  previousValues: DiagnosisPreviousValues
}

input DiagnosisSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DiagnosisWhereInput
  AND: [DiagnosisSubscriptionWhereInput!]
  OR: [DiagnosisSubscriptionWhereInput!]
  NOT: [DiagnosisSubscriptionWhereInput!]
}

input DiagnosisUpdateDataInput {
  use: String
  condition: ReferenceUpdateOneInput
}

input DiagnosisUpdateInput {
  use: String
  condition: ReferenceUpdateOneInput
}

input DiagnosisUpdateManyDataInput {
  use: String
}

input DiagnosisUpdateManyInput {
  create: [DiagnosisCreateInput!]
  update: [DiagnosisUpdateWithWhereUniqueNestedInput!]
  upsert: [DiagnosisUpsertWithWhereUniqueNestedInput!]
  delete: [DiagnosisWhereUniqueInput!]
  connect: [DiagnosisWhereUniqueInput!]
  set: [DiagnosisWhereUniqueInput!]
  disconnect: [DiagnosisWhereUniqueInput!]
  deleteMany: [DiagnosisScalarWhereInput!]
  updateMany: [DiagnosisUpdateManyWithWhereNestedInput!]
}

input DiagnosisUpdateManyMutationInput {
  use: String
}

input DiagnosisUpdateManyWithWhereNestedInput {
  where: DiagnosisScalarWhereInput!
  data: DiagnosisUpdateManyDataInput!
}

input DiagnosisUpdateWithWhereUniqueNestedInput {
  where: DiagnosisWhereUniqueInput!
  data: DiagnosisUpdateDataInput!
}

input DiagnosisUpsertWithWhereUniqueNestedInput {
  where: DiagnosisWhereUniqueInput!
  update: DiagnosisUpdateDataInput!
  create: DiagnosisCreateInput!
}

input DiagnosisWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  use: String
  use_not: String
  use_in: [String!]
  use_not_in: [String!]
  use_lt: String
  use_lte: String
  use_gt: String
  use_gte: String
  use_contains: String
  use_not_contains: String
  use_starts_with: String
  use_not_starts_with: String
  use_ends_with: String
  use_not_ends_with: String
  condition: ReferenceWhereInput
  AND: [DiagnosisWhereInput!]
  OR: [DiagnosisWhereInput!]
  NOT: [DiagnosisWhereInput!]
}

input DiagnosisWhereUniqueInput {
  id: ID
}

type Encounter {
  id: ID!
  subject: Reference!
  diagnosis(where: DiagnosisWhereInput, orderBy: DiagnosisOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Diagnosis!]
}

type EncounterConnection {
  pageInfo: PageInfo!
  edges: [EncounterEdge]!
  aggregate: AggregateEncounter!
}

input EncounterCreateInput {
  id: ID
  subject: ReferenceCreateOneInput!
  diagnosis: DiagnosisCreateManyInput
}

type EncounterEdge {
  node: Encounter!
  cursor: String!
}

enum EncounterOrderByInput {
  id_ASC
  id_DESC
}

type EncounterPreviousValues {
  id: ID!
}

type EncounterSubscriptionPayload {
  mutation: MutationType!
  node: Encounter
  updatedFields: [String!]
  previousValues: EncounterPreviousValues
}

input EncounterSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EncounterWhereInput
  AND: [EncounterSubscriptionWhereInput!]
  OR: [EncounterSubscriptionWhereInput!]
  NOT: [EncounterSubscriptionWhereInput!]
}

input EncounterUpdateInput {
  subject: ReferenceUpdateOneRequiredInput
  diagnosis: DiagnosisUpdateManyInput
}

input EncounterWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  subject: ReferenceWhereInput
  diagnosis_every: DiagnosisWhereInput
  diagnosis_some: DiagnosisWhereInput
  diagnosis_none: DiagnosisWhereInput
  AND: [EncounterWhereInput!]
  OR: [EncounterWhereInput!]
  NOT: [EncounterWhereInput!]
}

input EncounterWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createDiagnosis(data: DiagnosisCreateInput!): Diagnosis!
  updateDiagnosis(data: DiagnosisUpdateInput!, where: DiagnosisWhereUniqueInput!): Diagnosis
  updateManyDiagnoses(data: DiagnosisUpdateManyMutationInput!, where: DiagnosisWhereInput): BatchPayload!
  upsertDiagnosis(where: DiagnosisWhereUniqueInput!, create: DiagnosisCreateInput!, update: DiagnosisUpdateInput!): Diagnosis!
  deleteDiagnosis(where: DiagnosisWhereUniqueInput!): Diagnosis
  deleteManyDiagnoses(where: DiagnosisWhereInput): BatchPayload!
  createEncounter(data: EncounterCreateInput!): Encounter!
  updateEncounter(data: EncounterUpdateInput!, where: EncounterWhereUniqueInput!): Encounter
  upsertEncounter(where: EncounterWhereUniqueInput!, create: EncounterCreateInput!, update: EncounterUpdateInput!): Encounter!
  deleteEncounter(where: EncounterWhereUniqueInput!): Encounter
  deleteManyEncounters(where: EncounterWhereInput): BatchPayload!
  createReference(data: ReferenceCreateInput!): Reference!
  updateReference(data: ReferenceUpdateInput!, where: ReferenceWhereUniqueInput!): Reference
  updateManyReferences(data: ReferenceUpdateManyMutationInput!, where: ReferenceWhereInput): BatchPayload!
  upsertReference(where: ReferenceWhereUniqueInput!, create: ReferenceCreateInput!, update: ReferenceUpdateInput!): Reference!
  deleteReference(where: ReferenceWhereUniqueInput!): Reference
  deleteManyReferences(where: ReferenceWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  diagnosis(where: DiagnosisWhereUniqueInput!): Diagnosis
  diagnoses(where: DiagnosisWhereInput, orderBy: DiagnosisOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Diagnosis]!
  diagnosesConnection(where: DiagnosisWhereInput, orderBy: DiagnosisOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DiagnosisConnection!
  encounter(where: EncounterWhereUniqueInput!): Encounter
  encounters(where: EncounterWhereInput, orderBy: EncounterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Encounter]!
  encountersConnection(where: EncounterWhereInput, orderBy: EncounterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EncounterConnection!
  reference(where: ReferenceWhereUniqueInput!): Reference
  references(where: ReferenceWhereInput, orderBy: ReferenceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Reference]!
  referencesConnection(where: ReferenceWhereInput, orderBy: ReferenceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ReferenceConnection!
  node(id: ID!): Node
}

type Reference {
  id: ID!
  reference: String!
  type: String
  display: String
}

type ReferenceConnection {
  pageInfo: PageInfo!
  edges: [ReferenceEdge]!
  aggregate: AggregateReference!
}

input ReferenceCreateInput {
  id: ID
  reference: String!
  type: String
  display: String
}

input ReferenceCreateOneInput {
  create: ReferenceCreateInput
  connect: ReferenceWhereUniqueInput
}

type ReferenceEdge {
  node: Reference!
  cursor: String!
}

enum ReferenceOrderByInput {
  id_ASC
  id_DESC
  reference_ASC
  reference_DESC
  type_ASC
  type_DESC
  display_ASC
  display_DESC
}

type ReferencePreviousValues {
  id: ID!
  reference: String!
  type: String
  display: String
}

type ReferenceSubscriptionPayload {
  mutation: MutationType!
  node: Reference
  updatedFields: [String!]
  previousValues: ReferencePreviousValues
}

input ReferenceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ReferenceWhereInput
  AND: [ReferenceSubscriptionWhereInput!]
  OR: [ReferenceSubscriptionWhereInput!]
  NOT: [ReferenceSubscriptionWhereInput!]
}

input ReferenceUpdateDataInput {
  reference: String
  type: String
  display: String
}

input ReferenceUpdateInput {
  reference: String
  type: String
  display: String
}

input ReferenceUpdateManyMutationInput {
  reference: String
  type: String
  display: String
}

input ReferenceUpdateOneInput {
  create: ReferenceCreateInput
  update: ReferenceUpdateDataInput
  upsert: ReferenceUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ReferenceWhereUniqueInput
}

input ReferenceUpdateOneRequiredInput {
  create: ReferenceCreateInput
  update: ReferenceUpdateDataInput
  upsert: ReferenceUpsertNestedInput
  connect: ReferenceWhereUniqueInput
}

input ReferenceUpsertNestedInput {
  update: ReferenceUpdateDataInput!
  create: ReferenceCreateInput!
}

input ReferenceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  reference: String
  reference_not: String
  reference_in: [String!]
  reference_not_in: [String!]
  reference_lt: String
  reference_lte: String
  reference_gt: String
  reference_gte: String
  reference_contains: String
  reference_not_contains: String
  reference_starts_with: String
  reference_not_starts_with: String
  reference_ends_with: String
  reference_not_ends_with: String
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  display: String
  display_not: String
  display_in: [String!]
  display_not_in: [String!]
  display_lt: String
  display_lte: String
  display_gt: String
  display_gte: String
  display_contains: String
  display_not_contains: String
  display_starts_with: String
  display_not_starts_with: String
  display_ends_with: String
  display_not_ends_with: String
  AND: [ReferenceWhereInput!]
  OR: [ReferenceWhereInput!]
  NOT: [ReferenceWhereInput!]
}

input ReferenceWhereUniqueInput {
  id: ID
}

type Subscription {
  diagnosis(where: DiagnosisSubscriptionWhereInput): DiagnosisSubscriptionPayload
  encounter(where: EncounterSubscriptionWhereInput): EncounterSubscriptionPayload
  reference(where: ReferenceSubscriptionWhereInput): ReferenceSubscriptionPayload
}
